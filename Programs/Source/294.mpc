
from Compiler.program import Program
from Compiler import instructions_base
from Compiler import instructions
from random import randint
from Compiler import mpc_math
import sys
program.set_bit_length(128)

cserver_num = 3
aserver_num = 2

TO = Matrix(3, 3, sint)
TO[0][0] = 1
TO[0][1] = 0
TO[0][2] = 25
TO[1][0] = 0
TO[1][1] = 1
TO[1][2] = 25
TO[2][0] = 0
TO[2][1] = 0
TO[2][2] = 1


back_array = Matrix(3, 3, sint)
back_array[0][0] = 1
back_array[0][1] = 0
back_array[0][2] = -25
back_array[1][0] = 0
back_array[1][1] = 1
back_array[1][2] = -25
back_array[2][0] = 0
back_array[2][1] = 0
back_array[2][2] = 1
#NPLAYERS = regint(5)
#nplayers(regint(3))
#nplayers(5)
a = regint()
nplayers(a)
print_ln("%s", a)
def test(actual, expected):
	actual = actual.reveal()
	print_ln("expected %s, got %s", expected, actual)

index = sint(0)
#print_ln("0: %s", sint.get_input_from(0).reveal())
@for_range(cserver_num)
def _(i):
    index.update(index + sint.get_input_from(i))
index.update((index * sint(61))) 
index.update(index.int_div(sint(2160), 9)) #divide with a value larger than than what total number can be

# MOD INDEX
#index = sint.mod2m(index, 62, 64)
#index = index.mod2m(62, 64) 
#a = sint(1)
#b = sint(1)
#a = sint.mod2m(a, 256, 64)
#a = a.int_div(b, 2)
print_ln("index = %s", index.reveal())
#print_ln("a = %s", a.reveal())

data = Matrix(50, 50, sint)

def rotate():
    rot_angle = 0
    @for_range(cserver_num)
    def _(i):
        rot_angle.update(rot_angle + sint.get_input_from(i))
    rot_angle.update(rot_angle * sint(720))
    rot_angle.update(rot_angle.int_div(sint(2160)))
    rot_angle.update(rot_angle - sint(360)) 

    rot_matrix = Matrix(3, 3, sfix)
    rot_matrix[0][0] = mpc_math.cos(rot_angle)
    rot_matrix[0][1] = -1 * mpc_math.sin(rot_angle)
    rot_matrix[0][2] = 0
    rot_matrix[1][0] = mpc_math.sin(rot_angle)
    rot_matrix[1][1] = mpc_math.cos(rot_angle)
    rot_matrix[1][2] = 0
    rot_matrix[2][0] = 0
    rot_matrix[2][1] = 0
    rot_matrix[2][2] = 1

    A = TO.direct_mul(rot_matrix)
    final = A.direct_mul(back_array)
    return final


def scale():
    scale = Array(2, sfix)
    scale[0] = 0
    scale[1] = 0
    @for_range(cserver_num)
    def _(i):
        scale[0].update(scale[0] + sfix.get_input_from(i))
        scale[1].update(scale[1] + sfix.get_input_from(i))
    
    scale[0].update(scale[0] * sfix(3.0))
    scale[0].update(scale[0] / sfix(2160))
    scale[0].update(scale[0] + sfix(0.5))
    scale[1].update(scale[1] * sfix(3.0))
    scale[1].update(scale[1] / sfix(2160))
    scale[1].update(scale[1] + sfix(0.5))
    
    scale_matrix = Matrix(3,3,sfix)
    scale_matrix[0][0] = scale[0]
    scale_matrix[0][1] = 0
    scale_matrix[0][2] = 0
    scale_matrix[1][0] = 0
    scale_matrix[1][1] = scale[1]
    scale_matrix[1][2] = 0
    scale_matrix[2][0] = 0
    scale_matrix[2][1] = 0
    scale_matrix[2][2] = 1
    A = TO.direct_mul(scale_matrix)
    final = A.direct_mul(back_array)
    return final


def shear():
    shear = Array(2, sfix)
    shear[0] = 0
    shear[1] = 0
    @for_range(cserver_num)
    def _(i):
        shear[0].update(shear[0] + sfix.get_input_from(i))
        shear[1].update(shear[1] + sfix.get_input_from(i))
    shear[0].update(shear[0] * sfix(1.2))
    shear[0].update(shear[0] / sfix(2160))
    shear[1].update(shear[1] * sfix(1.2))
    shear[1].update(shear[1] / sfix(2160))
    

    shear_matrix = Matrix(3,3,sfix)
    shear_matrix[0][0] = 1
    shear_matrix[0][1] = shear[0]
    shear_matrix[0][2] = 0
    shear_matrix[1][0] = shear[1]
    shear_matrix[1][1] = 1
    shear_matrix[1][2] = 0
    shear_matrix[2][0] = 0
    shear_matrix[2][1] = 0
    shear_matrix[2][2] = 1
    A = TO.direct_mul(shear_matrix)
    final = A.direct_mul(back_array)
    return final

def translate():
    translate = Array(2, sint)
    translate[0] = 0
    translate[1] = 0
    @for_range(cserver_num)
    def _(i):
        translate[0].update(translate[0] + sint.get_input_from(i))
        translate[1].update(translate[1] + sint.get_input_from(i))
    translate[0].update(translate[0] * sint(40))
    translate[0].update(translate[0].int_div(2160,9))
    translate[0].update(translate[0] - sint(20)) 
    
    translate[1].update(translate[1] * sint(40))
    translate[1].update(translate[1].int_div(2160,9))
    translate[1].update(translate[1] - sint(20)) 
    trans_mat = Matrix(3,3,sint)
    trans_mat[0][0] = 1
    trans_mat[0][1] = 0
    trans_mat[0][2] = translate[0]
    trans_mat[1][0] = 0
    trans_mat[1][1] = 1
    trans_mat[1][2] = translate[1]
    trans_mat[2][0] = 0
    trans_mat[2][1] = 0
    trans_mat[2][2] = 1
    return trans_mat

def ones_like(matrix):
    new_matrix = matrix.same_shape()
    fill_with_ones_matrix = new_matrix(1)
    return fill_with_ones_matrix

def ravel(matrix):
    vec = sint.Array(matrix.rows * matrix.columns)
    return vec.assign_vector(matrix) 


#@for_range(50)
#def _(i):
 #   for j in range(50):
  #      data[i][j] = sint.get_input_from(0) #player 0 is the matrix data
#a = cint(1)
#b = sint(2)
#test(a + b, 3)

#print_ln("a = %s", a)
#print_ln("b = %s", b.reveal())

#Encrypt and MAC using APP servers:

""" Execfile can be avoided by implementing this ORAM-style
    (put .py sources in Compiler/ directory)
    - wanted to keep a clean directory structure hence
    used execfile

    This is HtMAC construction as specified in our ToSC paper:
        https://eprint.iacr.org/2017/496
    
    Line with (set_global_vector_size) says:
    'execute the PRF in n_parallel parallel instances'
    This unrolls to single instructions which execute n_parallel times
    in SPDZ on-line phase. (check the assembly code for more details
        by compiling with -a flag)

    For single instructions executing one time set n_parallel=1

    - test_decryption = False => Compute Enc() + Tag-Gen.
    - test_decryption = True  => Compute Enc() + Tag-Gen.
        Then compute Dec() + Tag-Check.

    Howto run?
        - Compile it via ./compile.py htmac n_parallel n_total nmessages
        Eg: ./compile.py 2 8 10
        Following compiles 8 HtMAC instances where 2 is the level of parallelism
        and each instance authenticates 10-block messages.
        A simplistic view of what is happening: 
        HtMAC(m) HtMAC(m) (1 run, 2 instances)
        HtMAC(m) HtMAC(m) (1 run, 2 instances)
        HtMAC(m) HtMAC(m) (1 run, 2 instances)
        HtMAC(m) HtMAC(m) (1 run, 2 instances)
        where |m| = 10 blocks
    
        - To run the online phase: ./Scripts/run-online htmac-2-8-10
"""

n_parallel = 1 #int(sys.argv[2])
n_total = 8 #int(sys.argv[3])
nmessages = 10 #int(sys.argv[4])

use_mimc_prf = True
# Use just one PRF
use_leg_prf = 1 - use_mimc_prf

test_decryption = True
instructions_base.set_global_vector_size(n_parallel)

if use_mimc_prf:
    exec(compile(__builtins__['open']('./Programs/Source/prf_mimc.mpc').read(), './Programs/Source/prf_mimc.mpc', 'exec'))
elif use_leg_prf:
    exec(compile(__builtins__['open']('./Programs/Source/prf_leg.mpc').read(), './Programs/Source/prf_leg.mpc', 'exec'))

class HMAC(object):
    def __init__(self, _enc):
        self.cipher = _enc

    def update_tweak(self, one_mask):
        self.one_mask = one_mask

    def default_auth(self, ciphertext):
        sigma = cint(0)
        m = nmessages
        E = self.cipher
        for i in range(m-1):
            sigma += ciphertext[i]

        digest = sigma.digest(16) # compute H(sigma)[0..127]

        # E^{-1,0}(digest) = E(digest + -1 * E(1))
        final_mask = digest + -1 * self.one_mask
        return final_mask

    def encryption_auth(self, ciphertext):
        # tag is clear
        final_mask = self.default_auth(ciphertext)
        return self.cipher.encrypt_ss_to_clear(final_mask)

    def decryption_auth(self, ciphertext):
        # tag is shared
        final_mask = self.default_auth(ciphertext)
        return self.cipher.encrypt_ss_to_ss(final_mask)

class NonceEncryptMAC(object):
    def __init__(self, _mac, _enc):
        self.mac = _mac
        self.enc = _enc

        self.one_mask = self.enc.encrypt_clear_to_ss(cint(1)) # E(1)

    def get_one_mask(self):
        return self.one_mask

    def get_long_random(self, nbits):
        """ Returns random cint() % 2^{nbits} """
        result = cint(0)
        for i in range(nbits // 30):
            result += cint(regint.get_random(30))
            result <<= 30

        result += cint(regint.get_random(nbits % 30))
        return result

    def apply(self, message):
        nonce = self.get_long_random(120)
        one_mask = self.one_mask
        blocks = [None] * nmessages

        for ctr in range(nmessages):
            # mask \asn E(N + i * E(1))
            mask = self.enc.encrypt_ss_to_ss(nonce + (ctr+1)*one_mask)
            temp = message[ctr] + mask
            blocks[ctr] = temp.reveal()

        return nonce, blocks, self.mac.encryption_auth(blocks)

    def default_decrypt(self, nonce, ciphertext):
        one_mask = self.one_mask
        blocks = [None] * nmessages

        for ctr in range(nmessages):
            mask = self.enc.encrypt_ss_to_ss(nonce + (ctr+1)*one_mask)
            blocks[ctr] = ciphertext[ctr] - mask

        computed_tag = self.mac.decryption_auth(ciphertext)
        return blocks, computed_tag

    def decrypt(self, nonce, ciphertext, recv_tag):
        message, computed_tag = self.default_decrypt(nonce, ciphertext)
        num_random = sint.get_random_triple()[0]

        zero_checker = num_random * (recv_tag - computed_tag)
        zero_checker = zero_checker.reveal()

        @if_(zero_checker != 0)
        def f():
            print_ln("MAC ERROR. PANIC")

        return message, computed_tag

    def checker(self, nonce, ciphertext, recv_tag):
        message, tag = self.decrypt(nonce, ciphertext, recv_tag)
        print_ln('decrypted plaintext:')
        for i in range(len(message)):
            print_str('%s ', message[i].reveal())
        print_ln()

key = sint(0)
def time_private_mac(n_total, n_parallel, nmessages):
    # The following line is to count required off-line data easier
    # by measuring amount of triples/bits used between blocks
    Program.prog.curr_tape.start_new_basicblock(name='preproc-block')

    num_calls = nmessages + 1
    # To test decryption we require 2(N+1) calls - (N+1)encrypt + (N+1)decrypt
    if test_decryption:
        num_calls *= 2

    enc_alg = None
    # branch on desired PRF
    key = sint(0)
    #key = Array(2, sint)
    if use_mimc_prf:
        #key = key + sint.get_input_from(0)
        @for_range(cserver_num, aserver_num + cserver_num)
        def f(i):
            print_ln("%s", i)
            #a = key
            #b = sint.get_input_from(i)
            #key = key + sint.get_input_from(i)
            #a = sint.get_input_from(i)
            key.update(key + sint.get_input_from(i))
            print_ln("ran %s", i)
        print_ln("key value %s", key.reveal())
        enc_alg = MiMC(73, key, num_calls)
    elif use_leg_prf:
        enc_alg = LegPRF(num_calls, bit_len=128)

    Program.prog.curr_tape.start_new_basicblock(name='preproc-block2')

    # Create HtMAC scheme
    auth_hmac = HMAC(enc_alg)
    auth_scheme = NonceEncryptMAC(auth_hmac, enc_alg)
    # Update tweak with E_k(1)
    auth_hmac.update_tweak(auth_scheme.get_one_mask())
    Program.prog.curr_tape.start_new_basicblock(name='online-block')

    # Benchmark n_total HtMAC's while executing in parallel n_parallel
    start_timer(1)
    @for_range(n_total // n_parallel)
    def block(index):
        # Re-use off-line data after n_parallel runs for benchmarking purposes.
        # If real system-use need to initialize num_calls with a larger constant.
        enc_alg.reset_kd_pre()
        message = [sint(2*i+1) for i in range(nmessages)]
        iv, ciphertext, tag = auth_scheme.apply(message)
        if test_decryption:
            auth_scheme.checker(iv, ciphertext, tag)

    stop_timer(1)

print_ln('##############################################')
time_private_mac(n_total, n_parallel, nmessages)
print_ln('##############################################')
